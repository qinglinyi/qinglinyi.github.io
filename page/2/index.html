<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>青林亦</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="知其然知其所以然">
<meta property="og:type" content="website">
<meta property="og:title" content="青林亦">
<meta property="og:url" content="http://www.qinglinyi.com/page/2/index.html">
<meta property="og:site_name" content="青林亦">
<meta property="og:description" content="知其然知其所以然">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="青林亦">
<meta name="twitter:description" content="知其然知其所以然">
  
    <link rel="alternative" href="/atom.xml" title="青林亦" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/images/header.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">青林亦</a></h1>
		</hgroup>

		
		<p class="header-subtitle">知其然知其所以然</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/hexo">Hexo</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/qinglinyi" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Broadcast/" style="font-size: 10px;">Broadcast</a> <a href="/tags/Fragment/" style="font-size: 10px;">Fragment</a> <a href="/tags/Github/" style="font-size: 10px;">Github</a> <a href="/tags/Handler/" style="font-size: 10px;">Handler</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Java基础/" style="font-size: 12.5px;">Java基础</a> <a href="/tags/Log/" style="font-size: 10px;">Log</a> <a href="/tags/Mac/" style="font-size: 10px;">Mac</a> <a href="/tags/Retrofit/" style="font-size: 10px;">Retrofit</a> <a href="/tags/Retrofit2/" style="font-size: 10px;">Retrofit2</a> <a href="/tags/Service/" style="font-size: 10px;">Service</a> <a href="/tags/String/" style="font-size: 10px;">String</a> <a href="/tags/property-animation/" style="font-size: 17.5px;">property animation</a> <a href="/tags/反射/" style="font-size: 10px;">反射</a> <a href="/tags/多线程/" style="font-size: 12.5px;">多线程</a> <a href="/tags/属性动画/" style="font-size: 17.5px;">属性动画</a> <a href="/tags/并发/" style="font-size: 12.5px;">并发</a> <a href="/tags/源码解析/" style="font-size: 10px;">源码解析</a> <a href="/tags/笔记/" style="font-size: 10px;">笔记</a> <a href="/tags/记录/" style="font-size: 10px;">记录</a> <a href="/tags/进程/" style="font-size: 10px;">进程</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">Android coder</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">青林亦</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/images/header.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">青林亦</h1>
			</hgroup>
			
			<p class="header-subtitle">知其然知其所以然</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/hexo">Hexo</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/qinglinyi" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-zipalign" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/zipalign/" class="article-date">
  	<time datetime="2016-10-24T06:26:07.000Z" itemprop="datePublished">2016-10-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/zipalign/">zipalign</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>zipalign是Android构建过程的一个环节，本文主要是翻译官网关于zipalign的介绍，并且配图。</p>
<h2 id="zipalign"><a href="#zipalign" class="headerlink" title="zipalign"></a>zipalign</h2><p><a href="https://developer.android.com/studio/command-line/zipalign.html" target="_blank" rel="external">https://developer.android.com/studio/command-line/zipalign.html</a></p>
<p>zipalign是一个归档对齐工具，它为Android应用程序（APK）文件提供重要的优化。 目的是确保所有未压缩数据以相对于文件开头的特定对齐开始。 具体来说，它会使APK中的所有未压缩数据（例如图像或raw）在4字节边界上对齐。 这允许使用mmap（）直接访问所有部分，即使它们包含具有对齐限制的二进制数据。 其优点是减少运行应用程序时消耗的RAM量。</p>
<p>此工具应始终用于在将APK文件分发给最终用户之前对齐。 Android构建工具可以为您处理此问题。 Android Studio会自动对齐您的APK。</p>
<blockquote>
<p>注意：您必须在应用程序构建过程中的两个特定点之一使用zipalign，具体取决于您使用的应用程序签名工具：</p>
<ol>
<li>如果您使用apksigner，zipalign只能在签署APK文件之前执行。 如果您使用apksigner签署APK，并对APK进行进一步更改，则其签名将失效。</li>
<li>如果你使用jarsigner，zipalign只能在APK文件签名后才能执行。</li>
</ol>
</blockquote>
<p><img src="/images/zipalign/zipalign.png" width="661" height="527" alt="apksigner"></p>
<p>通过更改zip本地文件头部分中“额外”字段的大小进行调整。 “额外”字段中的现有数据可能会被此过程更改。<br>有关如何在构建应用程序时使用zipalign的更多信息，请阅读签名您的应用程序。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>对齐 infile.apk 并保存为 outfile.apk:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zipalign [-f] [-v] &lt;alignment&gt; infile.apk outfile.apk</span><br></pre></td></tr></table></figure>
<p>确认existing.apk的对齐方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zipalign -c -v &lt;alignment&gt; existing.apk</span><br></pre></td></tr></table></figure>
<p>alignment是一个定义字节对齐边界的整数。 这必须总是4（提供32位对齐），否则它什么也不做。</p>
<p>标示:</p>
<ul>
<li>-f : 覆盖输出的 outfile.zip</li>
<li>-v : 详细输出</li>
<li>-p : outfile.zip应该对infile.zip中的所有共享对象文件使用相同的页面对齐</li>
<li>-c : 检查给定的文件是否对齐</li>
</ul>
<p>使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zipalign -c -v 4 destination.apk</span><br></pre></td></tr></table></figure>
<p>检查结果:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">       50 META-INF/MANIFEST.MF (OK - compressed)</span><br><span class="line">     467 META-INF/APP.SF (OK - compressed)</span><br><span class="line">     985 META-INF/APP.RSA (OK - compressed)</span><br><span class="line">    2142 res/drawable/ic_launcher.png (BAD - 2)</span><br><span class="line">    4391 res/layout/main.xml (OK - compressed)</span><br><span class="line">    4729 AndroidManifest.xml (OK - compressed)</span><br><span class="line">    5348 resources.arsc (OK)</span><br><span class="line">    6477 classes.dex (OK - compressed)</span><br><span class="line">Verification FAILED</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    49 AndroidManifest.xml (OK - compressed)</span><br><span class="line">     876 META-INF/CERT.RSA (OK - compressed)</span><br><span class="line">    1977 META-INF/CERT.SF (OK - compressed)</span><br><span class="line">   12956 META-INF/MANIFEST.MF (OK - compressed)</span><br><span class="line">   23893 classes.dex (OK - compressed)</span><br><span class="line"> ...</span><br><span class="line"> 1035004 res/mipmap-hdpi-v4/ic_launcher.png (OK)</span><br><span class="line"> 1038196 res/mipmap-mdpi-v4/ic_launcher.png (OK)</span><br><span class="line"> 1040224 res/mipmap-xhdpi-v4/ic_launcher.png (OK)</span><br><span class="line">...</span><br><span class="line"> 1201748 resources.arsc (OK)</span><br><span class="line">Verification succesful</span><br></pre></td></tr></table></figure>
<h2 id="配图"><a href="#配图" class="headerlink" title="配图"></a>配图</h2><p>看了<a href="http://mp.weixin.qq.com/s?__biz=MzI1NjEwMTM4OA==&amp;mid=2651232113&amp;idx=1&amp;sn=02f413999ab0865e23d272e69b9e6196&amp;scene=1&amp;srcid=0831gT4p6M0NFG5HTTeRHTUC#wechat_redirect" target="_blank" rel="external">Android构建过程分析</a>感觉不错，不过配图不是太好看，自己结合<a href="https://developer.android.com/studio/build/index.html" target="_blank" rel="external">官网的介绍</a>配了一个图。但是由于暂时不准备单独写一篇分析的文章，便放到了此处了。</p>
<p>不考虑Dependencies(Library Modules/AAR Libraries/JAR Libraries)，或者说将Dependencies理解成已经和Application Module进行marge了。</p>
<p><img src="/images/zipalign/Build Process.png" width="803" height="1368" alt="Build Process"></p>
<p>官网的构建配图是这样的：</p>
<p><img src="/images/zipalign/build-process_2x-2.png" width="475" height="534" alt="Build Process"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-ColorMatrix" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/ColorMatrix/" class="article-date">
  	<time datetime="2016-09-28T01:56:11.000Z" itemprop="datePublished">2016-09-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/ColorMatrix/">ColorMatrix</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>ColorMatrix是一个4x5的矩阵，是用于转换Bitmap的颜色和透明度的组件。这个矩阵可以通过一个简单的数组设置，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ a, b, c, d, e,</span><br><span class="line">  f, g, h, i, j,</span><br><span class="line">  k, l, m, n, o,</span><br><span class="line">  p, q, r, s, t ]</span><br></pre></td></tr></table></figure>
<p>当用于color [R, G, B, A]的时候，结果color将变成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">R’ = a*R + b*G + c*B + d*A + e;</span><br><span class="line">G’ = f*R + g*G + h*B + i*A + j;</span><br><span class="line">B’ = k*R + l*G + m*B + n*A + o;</span><br><span class="line">A’ = p*R + q*G + r*B + s*A + t;</span><br></pre></td></tr></table></figure>
<p>并且得到的结果 color [R’, G’, B’, A’]的每一项的取值范围都是0~255。</p>
<p>如下一个例子ColorMatrix是倒置每一项颜色：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ -1, 0, 0, 0, 255,</span><br><span class="line">  0, -1, 0, 0, 255,</span><br><span class="line">  0, 0, -1, 0, 255,</span><br><span class="line">  0, 0, 0, 1, 0 ]</span><br></pre></td></tr></table></figure>
<h2 id="二、主要方法"><a href="#二、主要方法" class="headerlink" title="二、主要方法"></a>二、主要方法</h2><ol>
<li>用于YUV和RGB转换的方法：setRGB2YUV()和setYUV2RGB()</li>
<li>用于设置饱和度的方法：setSaturation(float sat)，可以设置图片为黑白</li>
<li>用于调整颜色比例的方法：setScale(float rScale, float gScale, float bScale, float aScale)，可以调整R、G、B、A各项的比例</li>
<li><p>用于设置围绕一个颜色进行旋转（Set the rotation on a color axis by the specified values）：setRotate(int axis, float degrees)</p>
<p>1）<em>axis=0 Red</em>、<em>axis=1 Green</em>、<em>axis=2 Blue</em><br>2）<em>degrees</em> 角度 0-360</p>
</li>
</ol>
<h2 id="三、栗子"><a href="#三、栗子" class="headerlink" title="三、栗子"></a>三、栗子</h2><p><a href="https://github.com/qinglinyi/ColorMatrixDemo" target="_blank" rel="external">https://github.com/qinglinyi/ColorMatrixDemo</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-java-concurrency-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/java-concurrency-1/" class="article-date">
  	<time datetime="2016-06-23T11:30:26.000Z" itemprop="datePublished">2016-06-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/java-concurrency-1/">Java并发(2)-并发基础</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p>
<p>线程(Thread)是操作系统能够进行运算调度的最小单位。它被包涵在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>
<blockquote>
<p>进程让操作系统的并发性成为可能，而线程让进程的内部并发成为可能。<br>一个进程虽然包括多个线程，但是这些线程是共同享有进程占有的资源和地址空间的。进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位。</p>
</blockquote>
<p>来自&gt; <em><a href="http://www.cnblogs.com/dolphin0520/p/3910667.html" target="_blank" rel="external">Java并发编程：进程和线程之由来</a></em></p>
<h2 id="线程的生命周期（线程的状态）"><a href="#线程的生命周期（线程的状态）" class="headerlink" title="线程的生命周期（线程的状态）"></a>线程的生命周期（线程的状态）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public enum State &#123;</span><br><span class="line">   NEW,// 刚刚创建的线程，还没开始执行的时候</span><br><span class="line">   RUNNABLE, // 执行的时候</span><br><span class="line">   BLOCKED, // 等待锁的的时候，进入堵塞状态</span><br><span class="line">   WAITING, // 等待，无时间限制，wait通过notify唤醒，join通过目标线程终止后唤醒</span><br><span class="line">   TIMED_WAITING, // 进行一个 有时限的等待</span><br><span class="line">   TERMINATED; // 线程执行完毕，进入这个状态，表示结束。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>粗略的画了一张图：</p>
<p><img src="/images/concurrency/concurrency_thread_state.png" alt="线程的状态"></p>
<h2 id="初始线程：线程的基本操作"><a href="#初始线程：线程的基本操作" class="headerlink" title="初始线程：线程的基本操作"></a>初始线程：线程的基本操作</h2><h3 id="1-新建线程"><a href="#1-新建线程" class="headerlink" title="1.新建线程"></a>1.新建线程</h3><p>新建线程很简单。只要使用 new 关键字创建一个线程对象,并且将它start()起来即可。</p>
<p><strong>如果只调用run方法，那么只会在当前线程中执行run方法，只是作为一个普通的方法调用。</strong></p>
<p>线程的创建有两种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread t1=new Thread()&#123;</span><br><span class="line">   @Override</span><br><span class="line">   public void run()&#123;</span><br><span class="line">       System.out.println(&quot;Hello, I am t1&quot;);</span><br><span class="line">&#125; &#125;;</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t1=new Thread(new MyRunnable());</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure>
<h3 id="2-线程的终止"><a href="#2-线程的终止" class="headerlink" title="2.线程的终止"></a>2.线程的终止</h3><p>stop()方法已经废弃，因为stop()方法太过于暴力,强行把执行到一半的线程终止,可能会引起一些数据不一致的问题。建议的方式是定义了一个标记变量,用于指示线程是否需要退出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">public class StopThreadUnsafe &#123;</span><br><span class="line">    public static User u = new User();</span><br><span class="line"></span><br><span class="line">    public static class User &#123;</span><br><span class="line">        private int id;</span><br><span class="line">        private String name;</span><br><span class="line"></span><br><span class="line">        public User() &#123;</span><br><span class="line">            id = 0;</span><br><span class="line">            name = &quot;0&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int getId() &#123;</span><br><span class="line">            return id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setId(int id) &#123;</span><br><span class="line">            this.id = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getName() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setName(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return &quot;User [id=&quot; + id + &quot;, name=&quot; + name + &quot;]&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class ChangeObjectThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                synchronized (u) &#123;</span><br><span class="line">                    int v = (int) (System.currentTimeMillis() / 1000);</span><br><span class="line">                    u.setId(v);</span><br><span class="line">                    //Oh, do sth. else</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(100);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    u.setName(String.valueOf(v));</span><br><span class="line">                &#125;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class ReadObjectThread extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                synchronized (u) &#123;</span><br><span class="line">                    if (u.getId() != Integer.parseInt(u.getName())) &#123;</span><br><span class="line">                        System.out.println(u.toString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        new ReadObjectThread().start();</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            ChangeObjectThread t = new ChangeObjectThread();</span><br><span class="line">            t.start();</span><br><span class="line">            Thread.sleep(150);</span><br><span class="line">            t.stopMe();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">User [id=1466487989, name=1466487988]</span><br><span class="line">User [id=1466487990, name=1466487989]</span><br><span class="line">User [id=1466487990, name=1466487989]</span><br><span class="line">User [id=1466487990, name=1466487989]</span><br><span class="line">User [id=1466487990, name=1466487989]</span><br></pre></td></tr></table></figure>
<p>添加标记</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static class ChangeObjectThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">   volatile boolean stopMe = false;</span><br><span class="line"></span><br><span class="line">   public void stopMe() &#123;</span><br><span class="line">       stopMe = true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">       while (true) &#123;</span><br><span class="line">           synchronized (u) &#123;</span><br><span class="line">               if (stopMe) &#123;</span><br><span class="line">                   System.out.println(&quot;exit by stop me&quot;);</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">               int v = (int) (System.currentTimeMillis() / 1000);</span><br><span class="line">               u.setId(v);</span><br><span class="line">               //Oh, do sth. else</span><br><span class="line">               try &#123;</span><br><span class="line">                   Thread.sleep(100);</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               u.setName(String.valueOf(v));</span><br><span class="line">           &#125;</span><br><span class="line">           Thread.yield();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用stopMe结束线程。</p>
<h3 id="3-线程中断"><a href="#3-线程中断" class="headerlink" title="3.线程中断"></a>3.线程中断</h3><blockquote>
<p>在 Java 中，线程中断是一种重要的线程协作机制。从表面上理解，中断就是让目标线程停止执行的意思，实际上并非完全如此。严格地讲，线程中断并不会使线程立即退出，而是给线程发送一个通知，告知目标线程， 有人希望你退出啦！至于目标线程接到通知后如何处理，则完全由目标线程自行决定。</p>
</blockquote>
<p>相关的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void Thread.interrupt() // 中断线程</span><br><span class="line">public boolean Thread.isInterrupted() // 判断是否被中断</span><br><span class="line">public static boolean Thread.interrupted() // 判断是否被中断,并清除当前中断状态</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class InterruptedTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread t1 = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    if (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                        System.out.println(&quot;Interruted!&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(&quot;=========running=========&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(600);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        System.out.println(&quot;Interrupted When Sleep&quot;);</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(&quot;==running after sleep==&quot;);</span><br><span class="line">                    Thread.yield();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果不使用Thread.currentThread().isInterrupted()判断退出的话，是不会退出的。</li>
<li>如果添加Thread.sleep，那么要注意这个方法会由于线程的中断发生异常，并且此时会清除中断标记。所以在异常处理中,需要再次设置中断标记位。</li>
</ul>
<h3 id="等待（wait）和通知（notify）"><a href="#等待（wait）和通知（notify）" class="headerlink" title="等待（wait）和通知（notify）"></a>等待（wait）和通知（notify）</h3><p>为了支持多线程的协作，JDK提供了两个非常重要的方法wait和notify。这两个方法是属于Object类的方法。他们的签名是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public final void wait() throws InterruptedException</span><br><span class="line">public final native void notify()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当在一个对象实例上调用 wait()方法后,当前线程就会在这个对象上等待。这是什么意思呢?比如,线程 A 中，调用了obj.wait()方法，那么线程 A 就会停止继续执行，而转为等待状态。 等待到何时结束呢？线程 A 会一直等到其他线程调用了 obj.notify()方法为止。这时，obj 对象就俨然成为多个线程之间的有效通信手段。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class WaitAndNotifyDemo &#123;</span><br><span class="line"></span><br><span class="line">    static final Object obj = new Object();</span><br><span class="line"></span><br><span class="line">    static class T1 extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            synchronized (obj) &#123;</span><br><span class="line">                System.out.println(&quot;===T1 begin===&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    obj.wait();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;===T1 end===&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class T2 extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            synchronized (obj) &#123;</span><br><span class="line">                System.out.println(&quot;===T2 begin===&quot;);</span><br><span class="line">                obj.notifyAll();</span><br><span class="line">//                obj.notify();</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;===T2 end===&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class T3 extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            synchronized (obj) &#123;</span><br><span class="line">                System.out.println(&quot;===T3 begin===&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    obj.wait();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;===T3 end===&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new T1().start();</span><br><span class="line">        new T3().start();</span><br><span class="line">        new T2().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">===T1 begin===</span><br><span class="line">===T3 begin===</span><br><span class="line">===T2 begin===</span><br><span class="line">===T2 end===</span><br><span class="line">===T3 end===</span><br><span class="line">===T1 end===</span><br></pre></td></tr></table></figure>
<p>如例，wait和notify是对锁对象进行操作的，并且必须在 synchronized 函数或者代码块里面。wait的时候会释放锁，然后线程进入等待（WAITING），等待其他线程调用notify或者notifyAll方法（BLOCKED）并释放锁，然后wait线程获得锁继续执行（RUNNABLE）。假如在notify调用的时候锁还没被释放，那么还需要继续等待，直到重新获得锁。</p>
<blockquote>
<p><strong>注意：</strong>当notify()方法会从这个等待队列中，随机选择一个线程，并将其唤醒。而notifyAll()方法会唤醒在这个等待队列中所有等待的线程，而不是随机选择一个。</p>
</blockquote>
<p><strong>还要注意wait和sleep</strong>   wait和sleep都可以是线程进入等待。但是要注意他们之间的区别：</p>
<ol>
<li>这两个方法来自不同的类分别是Thread和Object。</li>
<li>最主要是sleep方法没有释放锁，而wait方法释放了锁。</li>
<li>wait，notify和notifyAll只能在synchronized同步控制方法或者synchronized同步控制块里面使用，而sleep没有这个限制。</li>
<li>sleep可以指定等待的时间，并且线程状态变为TIMED_WAITING。wait的等待时间不确定（当然还有一个wait超时方法，具有一个最长等待时间，状态也是变成TIMED_WAITING），需要根据notify的调用和锁的释放，并且线程进入的状态为WAITING。</li>
</ol>
<h3 id="5-挂起（suspend）和继续执行（resume）线程"><a href="#5-挂起（suspend）和继续执行（resume）线程" class="headerlink" title="5.挂起（suspend）和继续执行（resume）线程"></a>5.挂起（suspend）和继续执行（resume）线程</h3><blockquote>
<p>不推荐使用 suspend()去挂起线程的原因,是因为 suspend()在导致线程暂停的同时,并不会 去释放任何锁资源。此时,其他任何线程想要访问被它暂用的锁时,都会被牵连,导致无法正 常继续运行。直到对应的线程上进行了 resume()操作,被挂起的线程才能继续, 从而其他所有阻塞在相关锁上的线程也可以继续执行。但是,如果 resume()操作意外地在 suspend()前就执行了,那么被挂起的线程可能很难有机会被继续执行。并且,更严重的是:它 所占用的锁不会被释放,因此可能会导致整个系统工作不正常。而且,对于被挂起的线程,从 它的线程状态上看,居然还是 Runnable,这也会严重影响我们对系统当前状态的判断。</p>
</blockquote>
<p>那么如何完成线程的挂起和继续呢？使用wait和notify。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">public class GoodSuspend &#123;</span><br><span class="line">    public static Object u = new Object();</span><br><span class="line"></span><br><span class="line">    public static class ChangeObjectThread extends Thread &#123;</span><br><span class="line">        volatile boolean suspendme = false;</span><br><span class="line"></span><br><span class="line">        public void suspendMe() &#123;</span><br><span class="line">            suspendme = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void resumeMe() &#123;</span><br><span class="line">            suspendme = false;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line"></span><br><span class="line">                if (Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                    System.out.println(&quot;exit change&quot;);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                synchronized (this) &#123;</span><br><span class="line">                    while (suspendme) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            wait();</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            interrupt();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                synchronized (u) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        sleep(100);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(&quot;in ChangeObjectThread&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class ReadObjectThread extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line"></span><br><span class="line">                if (Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                    System.out.println(&quot;exit read&quot;);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                synchronized (u) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        sleep(100);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(&quot;in ReadObjectThread&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        ChangeObjectThread t1 = new ChangeObjectThread();</span><br><span class="line">        ReadObjectThread t2 = new ReadObjectThread();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        t1.suspendMe();</span><br><span class="line">        System.out.println(&quot;suspend t1 2 sec&quot;);</span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">        System.out.println(&quot;resume t1&quot;);</span><br><span class="line">        t1.resumeMe();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">        t2.interrupt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>前1秒，两个线程同时执行；</li>
<li>之后2秒t1挂起，只有t2执行；</li>
<li>然后t1、t2同时执行2秒</li>
<li>最后t1、t2中断</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">in ChangeObjectThread</span><br><span class="line">in ChangeObjectThread</span><br><span class="line">in ReadObjectThread</span><br><span class="line">in ReadObjectThread</span><br><span class="line">in ChangeObjectThread</span><br><span class="line">in ChangeObjectThread</span><br><span class="line">in ReadObjectThread</span><br><span class="line">in ReadObjectThread</span><br><span class="line">in ChangeObjectThread</span><br><span class="line">suspend t1 2 sec</span><br><span class="line">in ReadObjectThread</span><br><span class="line">in ChangeObjectThread</span><br><span class="line">in ReadObjectThread</span><br><span class="line">in ReadObjectThread</span><br><span class="line">in ReadObjectThread</span><br><span class="line">...</span><br><span class="line">in ReadObjectThread</span><br><span class="line">in ReadObjectThread</span><br><span class="line">in ReadObjectThread</span><br><span class="line">resume t1</span><br><span class="line">in ReadObjectThread</span><br><span class="line">in ChangeObjectThread</span><br><span class="line">in ReadObjectThread</span><br><span class="line">in ChangeObjectThread</span><br><span class="line">in ReadObjectThread</span><br><span class="line">in ChangeObjectThread</span><br><span class="line">in ReadObjectThread</span><br><span class="line">in ChangeObjectThread</span><br><span class="line">in ReadObjectThread</span><br><span class="line">in ReadObjectThread</span><br><span class="line">in ChangeObjectThread</span><br><span class="line">exit change</span><br><span class="line">in ReadObjectThread</span><br><span class="line">exit read</span><br></pre></td></tr></table></figure>
<h3 id="6-等待线程结束（join）和谦让（yield）"><a href="#6-等待线程结束（join）和谦让（yield）" class="headerlink" title="6.等待线程结束（join）和谦让（yield）"></a>6.等待线程结束（join）和谦让（yield）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure>
<p>第一个表示无限等待，会一直堵塞当前线程。第二个给出了个最大等待时间，超过时间继续执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                ++a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        AddThread addThread = <span class="keyword">new</span> AddThread();</span><br><span class="line">        addThread.start();</span><br><span class="line">        addThread.join();</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                ++a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        AddThread addThread = <span class="keyword">new</span> AddThread();</span><br><span class="line">        addThread.start();</span><br><span class="line">        addThread.join(<span class="number">500</span>);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同时对于join要注意，join()的本质是让调用线程wait()在当前线程对象实例上，因此不要在应用程序中，在Thread对象实例上使用类似wait()或者notify()等方法,因为这很有可能会影响系统API的工作，或者被系统API所影响。</p>
</blockquote>
<p>Thread.yield()方法表示让出CPU，但是它还回去竞争CPU资源。</p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>参考<a href="http://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="external">这里</a>和<a href="http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html" target="_blank" rel="external">这里</a></p>
<blockquote>
<p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<p>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p>
<p>2）禁止进行指令重排序。</p>
</blockquote>
<p>volatile关键字作用：</p>
<ol>
<li>保证可见性</li>
<li>不一定保证原子性</li>
<li>一定程度上的保证有序性</li>
</ol>
<h2 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h2><blockquote>
<p>在一个系统中，如果线程数量很多，而且功能分配比较明确，就可以将相同功能的线程放置在一个线程组里。打个比方，如果你有一个苹果，你就可以把它拿在手里，但是如果你有十 个苹果，你就最好还有一个篮子，否则不方便携带。对于多线程来说，也是这个道理。想要轻 处理几十个甚至上百个线程，最好还是将它们都装进对应的篮子里。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadGroupName implements Runnable &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        String name = Thread.currentThread().getThreadGroup().getName() + &quot;-&quot; + Thread.currentThread().getName();</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (Thread.currentThread().isInterrupted()) break;</span><br><span class="line">            System.out.println(&quot;I am &quot; + name);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(3000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        ThreadGroup tg = new ThreadGroup(&quot;PrintGroup&quot;);</span><br><span class="line">        Thread t1 = new Thread(tg, new ThreadGroupName(), &quot;T1&quot;);</span><br><span class="line">        Thread t2 = new Thread(tg, new ThreadGroupName(), &quot;T2&quot;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(tg.activeCount());</span><br><span class="line">        tg.list();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(4000);</span><br><span class="line">        tg.interrupt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过组合的形式，方便统一操作线程。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java基础/">Java基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Java/">Java</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-java-concurrency-0" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/java-concurrency-0/" class="article-date">
  	<time datetime="2016-06-22T08:30:26.000Z" itemprop="datePublished">2016-06-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/java-concurrency-0/">Java并发(1)-基础概念</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是将是一系列关于Java并发基础知识的文章。事实上，主要是《实战Java高并发程序设计》的读书笔记和网络资料以及对它们的整理。</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="1-同步Synchronous和异步Asynchronous"><a href="#1-同步Synchronous和异步Asynchronous" class="headerlink" title="1.同步Synchronous和异步Asynchronous"></a>1.同步Synchronous和异步Asynchronous</h3><p> 同步和异步通常是用来形容一次方法调用。</p>
<blockquote>
<p>所谓同步，就是在发出一个”调用”时，在没有得到结果之前，该”调用”就不返回。但是一旦调用返回，就得到返回值了。<br>换句话说，就是由”调用者”主动等待这个”调用”的结果。</p>
<p>而异步则是相反，”调用”在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在”调用”发出后，”被调用者”通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p>
</blockquote>
<p><em>来自&gt;知乎<a href="https://www.zhihu.com/question/19732473" target="_blank" rel="external">怎样理解阻塞非阻塞与同步异步的区别？</a></em></p>
<h3 id="2-并发、并行"><a href="#2-并发、并行" class="headerlink" title="2.并发、并行"></a>2.并发、并行</h3><blockquote>
<p>并发和并行的区别就是一个处理器同时处理多个任务和多个处理器或者是多核的处理器同时处理多个不同的任务。<br>前者是逻辑上的同时发生，而后者是物理上的同时发生。</p>
<p>并发性(concurrency)，又称共行性，是指能处理多个同时性活动的能力，并发事件之间不一定要同一时刻发生。</p>
<p>并行(parallelism)是指同时发生的两个并发事件，具有并发的含义，而并发则不一定并行。</p>
<p>来个比喻：并发和并行的区别就是一个人同时吃三个馒头和三个人同时吃三个馒头。</p>
</blockquote>
<p><img src="/images/concurrency/concurrency_byb.jpg" alt="并发与并行示例"></p>
<p><em>来自&gt; <a href="http://developer.51cto.com/art/200908/141553.htm" target="_blank" rel="external">并发和并行的区别：吃馒头的比喻</a></em></p>
<h3 id="3-临界区"><a href="#3-临界区" class="headerlink" title="3. 临界区"></a>3. 临界区</h3><p>用来表示一种公共资源可以被多个线程使用，但是每次只允许一个线程使用它，一旦临界区资源被占用，其他资源想要访问它只能等待。</p>
<h3 id="4-堵塞和非堵塞"><a href="#4-堵塞和非堵塞" class="headerlink" title="4. 堵塞和非堵塞"></a>4. 堵塞和非堵塞</h3><p>堵塞和非堵塞用来形容线程相互影响的一种状态，比如一个线程占用了临界区资源，那么其他所以线程需要使用这个资源并且等待，等待会导致线程挂起，这便是堵塞。非堵塞相反，表示线程没有被其他线程妨碍，会不断尝试向前执行。</p>
<h3 id="5-死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）"><a href="#5-死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）" class="headerlink" title="5. 死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）"></a>5. 死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）</h3><p>死锁饥饿和活锁都是用来形容多线程的活跃性。</p>
<ul>
<li>死锁：是指两个或者两个以上的进程执行过程中，由于竞争资源或者由于彼此通信而造成的一种堵塞的现象，若无外力的作用，他们都将无法推进下去。</li>
<li>饥饿：是指线程一直无法获取资源，导致一个堵塞。例如可能是因为优先级太低，而高优先级的线程一直抢占它需要的资源导致低级线程无法工作。</li>
<li>活锁：是指任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。</li>
</ul>
<h2 id="并发级别"><a href="#并发级别" class="headerlink" title="并发级别"></a>并发级别</h2><p>由于临界区的存在,多线程之间的并发必须受到控制。根据控制并发的策略,我们可以把并发的级别进行分类,大致上可以分为阻塞、无饥饿、无障碍、无锁、无等待几种。</p>
<h3 id="1-堵塞（Blocking）"><a href="#1-堵塞（Blocking）" class="headerlink" title="1.堵塞（Blocking）"></a>1.堵塞（Blocking）</h3><p>一个线程是阻塞的,那么在其他线程释放资源之前,当前线程无法继续执行。</p>
<h3 id="2-无饥饿（Starvation-Free）"><a href="#2-无饥饿（Starvation-Free）" class="headerlink" title="2.无饥饿（Starvation-Free）"></a>2.无饥饿（Starvation-Free）</h3><p>如果锁是公平的，满足所有的线程按照顺序排队（高优先级的线程不插队），那么所有的线程都有执行机会。</p>
<h3 id="3-无障碍（Obstruction-Free）"><a href="#3-无障碍（Obstruction-Free）" class="headerlink" title="3.无障碍（Obstruction-Free）"></a>3.无障碍（Obstruction-Free）</h3><p>表示所有线程都可以访问临界区，为了保证数据安全，如果线程发生冲突就回滚。</p>
<h3 id="4-无锁（Lock-Free）"><a href="#4-无锁（Lock-Free）" class="headerlink" title="4.无锁（Lock-Free）"></a>4.无锁（Lock-Free）</h3><p>在无锁的情况下，所有的线程都能尝试对临界区进行访问，但不同的是，无锁的并发保证必然有一个线程能够在有限步内完成操作离开临界区。</p>
<h3 id="5-无等待（Wait-Free）"><a href="#5-无等待（Wait-Free）" class="headerlink" title="5.无等待（Wait-Free）"></a>5.无等待（Wait-Free）</h3><p>无锁只要求有一个线程可以在有限步内完成操作,而无等待则在无锁的基础上更进一步进行扩展。它要求所有的线程都必须在有限步内完成,这样就不会引起饥饿问题。如果限制这个步骤上限,还可以进一步分解为有界无等待和线程数无关的无等待几种,它们之间的区别只是对循环次数的限制不同。</p>
<p>一种典型的无等待结构就是 RCU(Read-Copy-Update)。它的基本思想是,对数据的读可以不加控制。</p>
<h2 id="原子性、可见性、有序性"><a href="#原子性、可见性、有序性" class="headerlink" title="原子性、可见性、有序性"></a>原子性、可见性、有序性</h2><p>Java内存模型是围绕着并发过程中如何处理原子性、可见性、有序性这三个特征来建立的，下面是这三个特性的实现原理：</p>
<h3 id="1-原子性（Atomicity）"><a href="#1-原子性（Atomicity）" class="headerlink" title="1.原子性（Atomicity）"></a>1.原子性（Atomicity）</h3><p>原子性表示一个操作不可中断，即使在多个线程一起执行的时候，一个操作一旦开始就不会被其他线程干扰。</p>
<h3 id="2-可见性（Visibility）"><a href="#2-可见性（Visibility）" class="headerlink" title="2.可见性（Visibility）"></a>2.可见性（Visibility）</h3><p>可见性是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改。</p>
<h3 id="3-有序性（Ordering）"><a href="#3-有序性（Ordering）" class="headerlink" title="3.有序性（Ordering）"></a>3.有序性（Ordering）</h3><p>有序性问题的原因是因为程序在执行时，可能会进行指令重排，重排后的指令与原指令的顺序未必一致。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java基础/">Java基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Java/">Java</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-logger" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/logger/" class="article-date">
  	<time datetime="2016-06-07T03:03:59.000Z" itemprop="datePublished">2016-06-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/logger/">Logger源码解析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>介绍一个Logger的源码（版本：1.12）。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Logger是android.util.Log日志类的封装，但是<em>更美观、更简单、更强大</em>。<br>使用介绍、详细内容移步<a href="https://github.com/orhanobut/logger" target="_blank" rel="external">GitHub</a>。</p>
<p>Logger能干什么：</p>
<ul>
<li>线程信息</li>
<li>类信息</li>
<li>方法信息</li>
<li>美观的Json内容</li>
<li>美观的换行”\n”</li>
<li>转跳到源码</li>
</ul>
<p>简单使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Logger</span><br><span class="line">  .init(YOUR_TAG)                 // default PRETTYLOGGER or use just init()</span><br><span class="line">  .methodCount(3)                 // default 2</span><br><span class="line">  .hideThreadInfo()               // default shown</span><br><span class="line">  .logLevel(LogLevel.NONE)        // default LogLevel.FULL</span><br><span class="line">  .methodOffset(2)                // default 0</span><br><span class="line">  .logTool(new AndroidLogTool()); // custom log tool, optional</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h2><p>各类和接口的关系如下图：</p>
<p><img src="/images/logger/Logger_class.png" alt="类关系图"></p>
<h3 id="1-Logger类"><a href="#1-Logger类" class="headerlink" title="1.Logger类"></a>1.Logger类</h3><p>提供一个静态Printer,处理打印。相当于对printer类的包装。</p>
<p><img src="/images/logger/Logger_methods.png" alt="Logger结构"></p>
<p>1）init初始化<br>2）clear清除<br>3）t 设置打印tag<br>4）执行打印的i,w,e等</p>
<p>这些方法都是调用成员变量printer来执行，所以说Logger其实就是Printer的包装。</p>
<h3 id="2-Printer接口"><a href="#2-Printer接口" class="headerlink" title="2.Printer接口"></a>2.Printer接口</h3><p>真正执行处理打印的接口，LoggerPrinter是其子类。</p>
<h3 id="3-LoggerPrinter类"><a href="#3-LoggerPrinter类" class="headerlink" title="3.LoggerPrinter类"></a>3.LoggerPrinter类</h3><p>Printer的子类，Logger使用它进行处理、美化、包装打印信息调用它的各种方法例如init、clear、t、i、w等。</p>
<h3 id="4-Settings类"><a href="#4-Settings类" class="headerlink" title="4.Settings类"></a>4.Settings类</h3><p>主要用来设置打印的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private int methodCount = 2;//打印方法的方法数</span><br><span class="line">private boolean showThreadInfo = true;//是否显示线程信息</span><br><span class="line">private int methodOffset = 0;// 打印方法Offset，跳过几个方法开始打印方法</span><br><span class="line">private LogTool logTool;// 真正执行打印的类</span><br><span class="line">private LogLevel logLevel = LogLevel.FULL;// 打印的级别</span><br></pre></td></tr></table></figure>
<h3 id="5-LogLevel枚举"><a href="#5-LogLevel枚举" class="headerlink" title="5.LogLevel枚举"></a>5.LogLevel枚举</h3><p>打印的级别的枚举</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum LogLevel &#123;</span><br><span class="line">  // 打印所以信息</span><br><span class="line">  FULL,</span><br><span class="line">  // 不打印信息</span><br><span class="line">  NONE </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-LogTool接口"><a href="#6-LogTool接口" class="headerlink" title="6.LogTool接口"></a>6.LogTool接口</h3><p>LogTool是真正用来打印的，在Printer中调用LogTool执行打印。可以通过Settings类设置自定义的LogTool。默认使用AndroidLogTool。</p>
<h3 id="7-AndroidLogTool类"><a href="#7-AndroidLogTool类" class="headerlink" title="7.AndroidLogTool类"></a>7.AndroidLogTool类</h3><p>实现LogTool接口，使用系统的Log执行打印。</p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>Logger的重点是Printer，所以我们来解析一下LoggerPrinter类。</p>
<h3 id="1）init"><a href="#1）init" class="headerlink" title="1）init"></a>1）init</h3><p>设置默认的Tag和设置Settings，该方法返回一个Settings实例。再看一下使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Logger</span><br><span class="line">  .init(YOUR_TAG)                 // default PRETTYLOGGER or use just init()</span><br><span class="line">  .methodCount(3)                 // default 2</span><br><span class="line">  .hideThreadInfo()               // default shown</span><br><span class="line">  .logLevel(LogLevel.NONE)        // default LogLevel.FULL</span><br><span class="line">  .methodOffset(2)                // default 0</span><br><span class="line">  .logTool(new AndroidLogTool()); // custom log tool, optional</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2）t"><a href="#2）t" class="headerlink" title="2）t"></a>2）t</h3><p>设置tag和打印的方法数，不过这个设置只有一次使用有效。并且使用ThreadLocal来保证线程安全。<br>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Logger.t(&quot;mytag&quot;).d(&quot;hello&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="3）打印"><a href="#3）打印" class="headerlink" title="3）打印"></a>3）打印</h3><p>我们看一下任意一个打印方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Override public void d(String message, Object... args) &#123;</span><br><span class="line">  log(DEBUG, message, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以的打印方法都是使用log方法，只是打印的logType不同。</p>
<p>我们来看看log方法：</p>
<p><img src="/images/logger/Logger_log.png" alt="log方法"></p>
<p>然后我们将他简化成一个示意图：</p>
<p><img src="/images/logger/Logger_log_info.png" alt="log方法示意图"></p>
<p>除去打印边框和分割线，主要就是<strong><em>logHeaderContent</em></strong>、<strong><em>logContent</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private void logHeaderContent(int logType, String tag, int methodCount) &#123;</span><br><span class="line">	 // 获取当前堆栈跟踪，能够获取调用的打印的类和方法路劲</span><br><span class="line">   StackTraceElement[] trace = Thread.currentThread().getStackTrace();</span><br><span class="line">   // 打印线程信息</span><br><span class="line">   if (settings.isShowThreadInfo()) &#123;</span><br><span class="line">     logChunk(logType, tag, HORIZONTAL_DOUBLE_LINE + &quot; Thread: &quot; + Thread.currentThread().getName());</span><br><span class="line">     logDivider(logType, tag);</span><br><span class="line">   &#125;</span><br><span class="line">   String level = &quot;&quot;;</span><br><span class="line">   </span><br><span class="line">  // 获取需要打印的方法在数组中的位置</span><br><span class="line">   int stackOffset = getStackOffset(trace) + settings.getMethodOffset();</span><br><span class="line"></span><br><span class="line">   //corresponding method count with the current stack may exceeds the stack trace. Trims the count</span><br><span class="line">   if (methodCount + stackOffset &gt; trace.length) &#123;</span><br><span class="line">     methodCount = trace.length - stackOffset - 1;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   for (int i = methodCount; i &gt; 0; i--) &#123;</span><br><span class="line">     int stackIndex = i + stackOffset;</span><br><span class="line">     if (stackIndex &gt;= trace.length) &#123;</span><br><span class="line">       continue;</span><br><span class="line">     &#125;</span><br><span class="line">     StringBuilder builder = new StringBuilder();</span><br><span class="line">     builder.append(&quot;║ &quot;)</span><br><span class="line">         .append(level)</span><br><span class="line">         .append(getSimpleClassName(trace[stackIndex].getClassName()))</span><br><span class="line">         .append(&quot;.&quot;)</span><br><span class="line">         .append(trace[stackIndex].getMethodName())</span><br><span class="line">         .append(&quot; &quot;)</span><br><span class="line">         .append(&quot; (&quot;)</span><br><span class="line">         .append(trace[stackIndex].getFileName())</span><br><span class="line">         .append(&quot;:&quot;)</span><br><span class="line">         .append(trace[stackIndex].getLineNumber())</span><br><span class="line">         .append(&quot;)&quot;);</span><br><span class="line">     level += &quot;   &quot;;</span><br><span class="line">     logChunk(logType, tag, builder.toString());</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void logContent(int logType, String tag, String chunk) &#123;</span><br><span class="line">  String[] lines = chunk.split(System.getProperty(&quot;line.separator&quot;));</span><br><span class="line">  for (String line : lines) &#123;</span><br><span class="line">    logChunk(logType, tag, HORIZONTAL_DOUBLE_LINE + &quot; &quot; + line);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不管是哪个打印方法，都是调用<strong><em>logChunk</em></strong>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void logChunk(int logType, String tag, String chunk) &#123;</span><br><span class="line">      ...</span><br><span class="line">        settings.getLogTool().e(finalTag, chunk);</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>然后就调用LogTool的打印方法。</p>
<p>看看LogTool：</p>
<p><img src="/images/logger/Logger_tool.png" alt="log方法示意图"></p>
<p>调用android.util.Log的方法。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Log/">Log</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码解析/">源码解析</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-about-android-handler" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/about-android-handler/" class="article-date">
  	<time datetime="2016-05-16T08:51:51.000Z" itemprop="datePublished">2016-05-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/about-android-handler/">Android Handler消息机制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>就应用程序而言，Android系统中Java的应用程序和其他系统上相同，都是靠消息驱动来工作的，它们大致的工作原理如下：</p>
<ol>
<li>有一个消息队列，可以往这个消息队列中投递消息。</li>
<li>有一个消息循环，不断从消息队列中获取消息，然后处理。</li>
</ol>
</blockquote>
<p>示意图如下：</p>
<p><img src="/images/handler/handler_shiyi.png" alt="消息示意图"></p>
<ul>
<li>事件源把需要处理的消息加入到消息队列中，一般是放到队列的队尾，或者安装优先级来放置消息。</li>
<li>处理线程不断从消息队列中提取消息并处理。</li>
</ul>
<p>在Android系统中，这个消息机制是有Looper（包含一个MessageQueue）和Handler来完成的。</p>
<ul>
<li>Looper类，用于封装消息循环，并且包含一个消息队列MessageQueue。</li>
<li>Handler类，封装了消息的投递和消息的处理。</li>
</ul>
<blockquote>
<p>本文主要从Framework层展开的，对Native层的展开推荐<a href="http://www.cnblogs.com/angeldevil/p/3340644.html" target="_blank" rel="external">这篇文章</a>。</p>
</blockquote>
<h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><p>消息机制，最基础的应该就是这个载体——消息了。Android上使用Message类表示一个消息，这个Message可以通过Handler传递，通过Looper进行分发，通过MessageQueue进行排列组队，最后通过Handler进行处理。</p>
<p>先看一下Message的基本成员，我们在使用中经常会用到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 用来保存消息标示，不同的Handler拥有不同的命名空间（name-space），不同担心what冲突</span><br><span class="line">public int what;</span><br><span class="line">// arg1和arg2是用来存放整型数据的</span><br><span class="line">public int arg1; </span><br><span class="line">public int arg2;</span><br><span class="line">// Object类型的任意对象</span><br><span class="line">public Object obj;</span><br><span class="line"></span><br><span class="line">// replyTo和replyTo与Messenger通信相关</span><br><span class="line">public Messenger replyTo;</span><br><span class="line">public int replyTo = -1;</span><br></pre></td></tr></table></figure>
<p><strong><em>关于replyTo可以查看<a href="http://blog.csdn.net/lmj623565791/article/details/47017485" target="_blank" rel="external">这里</a>和<a href="https://developer.android.com/reference/android/app/Service.html#RemoteMessengerServiceSample" target="_blank" rel="external">这里</a></em></strong></p>
<p>还有消息机制中重要的成员：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 标记消息，FLAG_IN_USE，FLAG_ASYNCHRONOUS等</span><br><span class="line">int flags;</span><br><span class="line">// 消息的投递时间，单位为毫秒</span><br><span class="line">long when;</span><br><span class="line">// 传递的数据</span><br><span class="line">Bundle data;</span><br><span class="line">// 消息最终执行的Handler  </span><br><span class="line">Handler target;  </span><br><span class="line">// 消息执行时的回调，Handler post的Runnable</span><br><span class="line">Runnable callback;</span><br><span class="line">// 下一个消息，通过next可以实现一个链表</span><br><span class="line">Message next;</span><br></pre></td></tr></table></figure>
<p>并且，Message内部保存了一个缓存的消息池，我们可以用obtain从缓存池获得一个消息，Message使用完后系统会调用recycle回收。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Message缓存链表</span><br><span class="line">private static Message sPool;</span><br><span class="line">// 缓存最大值</span><br><span class="line">private static final int MAX_POOL_SIZE = 50;</span><br></pre></td></tr></table></figure>
<p>那么，缓存和回收是怎么实现的？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static Message obtain() &#123;</span><br><span class="line">   synchronized (sPoolSync) &#123;</span><br><span class="line">       if (sPool != null) &#123;</span><br><span class="line">           Message m = sPool;</span><br><span class="line">           sPool = m.next;</span><br><span class="line">           m.next = null;</span><br><span class="line">           m.flags = 0; // clear in-use flag</span><br><span class="line">           sPoolSize--;</span><br><span class="line">           return m;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return new Message();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过obtain获取缓存池链表的第一个Message返回，将第一个Message的next的Message作为第一个。其实就是查看缓存池是否有对象，有就返回缓存的对象，没有就创建新对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void recycleUnchecked() &#123;</span><br><span class="line">   flags = FLAG_IN_USE;</span><br><span class="line">   what = 0;</span><br><span class="line">   arg1 = 0;</span><br><span class="line">   arg2 = 0;</span><br><span class="line">   obj = null;</span><br><span class="line">   replyTo = null;</span><br><span class="line">   sendingUid = -1;</span><br><span class="line">   when = 0;</span><br><span class="line">   target = null;</span><br><span class="line">   callback = null;</span><br><span class="line">   data = null;</span><br><span class="line"></span><br><span class="line">   synchronized (sPoolSync) &#123;</span><br><span class="line">       if (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">           next = sPool;</span><br><span class="line">           sPool = this;</span><br><span class="line">           sPoolSize++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回收Message的时候，如果缓存池没满的话，将Message的成员清空之后放入缓存池。</p>
<p><strong>由于Message具有缓存能力，所以我们在创建Message对象的时候最好使用obtain。</strong></p>
<h2 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h2><p>消息Message通过Handler传递给Looper，Looper通过封装一个消息队列MessageQueue来进行消息存放和分发。</p>
<p>Looper类主要是通过prepare方法进行准备和loop方法进行循环获取消息队列的消息进行分发处理。</p>
<h3 id="1-prepare"><a href="#1-prepare" class="headerlink" title="1.prepare"></a>1.prepare</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">    if (sThreadLocal.get() != null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过prepare方法，为当前调用线程生成一个Looper对象，这个对象保存在ThreadLocal(<a href="http://qifuguang.me/2015/09/02/%5BJava并发包学习七%5D解密ThreadLocal/" target="_blank" rel="external">关于ThreadLocal</a>)中。通过这种方式使Looper和调用线程（最终的处理线程）进行关联，保证每个调用线程只会有一个Looper对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private Looper(boolean quitAllowed) &#123;</span><br><span class="line">   mQueue = new MessageQueue(quitAllowed);</span><br><span class="line">   mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Looper在构成方法中，新建一个消息队列和获取当前线程。构成方法的参数quitAllowed，是给MessageQueue使用的，用来标记这个消息队列（同时也是这个Looper）能否终止运行。</p>
<h3 id="2-loop"><a href="#2-loop" class="headerlink" title="2.loop"></a>2.loop</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void loop() &#123;</span><br><span class="line">   final Looper me = myLooper();//获取ThreadLocal保存的Looper对象</span><br><span class="line">   ...</span><br><span class="line">   // 取出消息队列</span><br><span class="line">   final MessageQueue queue = me.mQueue;</span><br><span class="line">   ...</span><br><span class="line">   // 循环获取消息队列的消息</span><br><span class="line">   for (;;) &#123;</span><br><span class="line">   		 //获取队列的下一条消息，可能堵塞</span><br><span class="line">       Message msg = queue.next(); // might block </span><br><span class="line">       if (msg == null) &#123; // 如果没有消息退出循环</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">       // 调用消息的target（其实就是Handler）分发消息，让Handler处理这个消息</span><br><span class="line">       msg.target.dispatchMessage(msg);</span><br><span class="line">       ...</span><br><span class="line">       // 回收消息对象</span><br><span class="line">       msg.recycleUnchecked();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>loop将进行无限循环，更加消息队列MessageQueue的next进行退出，next方法可能堵塞（休眠），MessageQueue的休眠和唤醒机制是通过Native层完成，是一种epoll机制。</p>
<p><strong>详细的native方面的讲解见<a href="http://www.cnblogs.com/angeldevil/p/3340644.html" target="_blank" rel="external">这里</a>和<a href="http://blog.csdn.net/xcy2011sky/article/details/25960849" target="_blank" rel="external">这里</a></strong></p>
<h2 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h2><p>MessageQueue类是Looper类分装消息列表的类，包含一个消息列表，这个列表通过Looper进行消息分发。</p>
<blockquote>
<p>Messages are not added directly to a MessageQueue,but rather through {@link Handler} objects associated with the Looper.</p>
</blockquote>
<p>Message不是直接添加到MessageQueue的，而是通过Handler将它与Looper关联的。</p>
<p>1）添加消息（enqueueMessage）</p>
<p>向队列中添加消息，是通过Handler的sendMessage等方法，然后执行Handler的enqueueMessage方法调用MessageQueue的enqueueMessage。enqueueMessage方法会更加Message的when添加到合适的队列的相应的位置。</p>
<p>2）获取消息（next）</p>
<p>loop每次从MessageQueue取出一个Message（通过next方法），分发，在Handler中处理消息，之后进行回收。</p>
<h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>Handler类，封装了消息的投递和消息的处理。这个类是很多文章中都讲的很详细的一个类，这里就简单介绍了。</p>
<h3 id="1-构造"><a href="#1-构造" class="headerlink" title="1 构造"></a>1 构造</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Handler(Looper looper, Callback callback, boolean async) &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>通过构造方法设置Looper，Callback，async。其中async是设置Message的setAsynchronous。</p>
<p>1）Looper</p>
<p>Handler必须需要使用Looper，不过使用带有Looper的构成方法的时候，是使用当前线程的Looper。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mLooper = Looper.myLooper();</span><br></pre></td></tr></table></figure>
<p>2) Callback</p>
<p>这里消息时候的回调，在处理消息的时候使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void dispatchMessage(Message msg) &#123;</span><br><span class="line">   if (msg.callback != null) &#123;</span><br><span class="line">       handleCallback(msg);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       if (mCallback != null) &#123;</span><br><span class="line">           if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       handleMessage(msg);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，在创建Handler的时候，为了实现处理消息，除了可以使用自己实现Handler的handleMessage方法的形式，还可以使用一个Callback来完成。</p>
<h3 id="2-消息投递"><a href="#2-消息投递" class="headerlink" title="2 消息投递"></a>2 消息投递</h3><p>消息的投递有好几种方式，sendMessage、sendEmptyMessage、sendEmptyMessageDelayed…、post等，最终都是调用enqueueMessage。只是不同的方法，生成不同形式的Message。例如post方法，就是生成（obtain）一个Message，然后设置Message的callback。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static Message getPostMessage(Runnable r) &#123;</span><br><span class="line">   Message m = Message.obtain();</span><br><span class="line">   m.callback = r;</span><br><span class="line">   return m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-消息处理"><a href="#3-消息处理" class="headerlink" title="3 消息处理"></a>3 消息处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void dispatchMessage(Message msg) &#123;</span><br><span class="line">   if (msg.callback != null) &#123;</span><br><span class="line">       handleCallback(msg);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       if (mCallback != null) &#123;</span><br><span class="line">           if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       handleMessage(msg);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Looper的loop调用Handler的dispatchMessage进行消息的处理。如果回调mCallback存在的话，使用会滴处理，如果不存在的话使用handleMessage处理。</p>
<h2 id="Android主线程消息机制"><a href="#Android主线程消息机制" class="headerlink" title="Android主线程消息机制"></a>Android主线程消息机制</h2><p>Android在主线程已经为我们提供了一个Looper，所以我们在主线程任意创建Handler（不传入Looper，是当前前程的Looper），同Handler可以实现向主线程进行消息的投递，并且在主线程进行消息的处理，达到异步消息传递的效果。</p>
<p><img src="/images/handler/handler_main.png" alt="主线程初始化Looper"></p>
<p>主线程在启动的时候，调用Looper的prepareMainLooper，loop启动Looper。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void prepareMainLooper() &#123;</span><br><span class="line">   prepare(false);</span><br><span class="line">   synchronized (Looper.class) &#123;</span><br><span class="line">       if (sMainLooper != null) &#123;</span><br><span class="line">           throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       sMainLooper = myLooper();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>prepare传入false，那么这个消息循环是不允许用户结束。</p>
<h2 id="自定义消息线程"><a href="#自定义消息线程" class="headerlink" title="自定义消息线程"></a>自定义消息线程</h2><p>如果我们需要实现Handler传递的消息是传递到我们的自己的线程，要怎么实现呢？</p>
<p>我们知道只要将在线程中调用Looper的prepare方法为这个线程生成Looper对象，然后调用loop方法，使Looper启动循环。然后将Looper对象传递给Handler，Handler在其他线程投递消息，就实现了消息在其他线程传递到Looper的线程。</p>
<p>事实上，Android已经为我们提供了一个HandlerThread来实现这个功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">   mTid = Process.myTid();</span><br><span class="line">   Looper.prepare();</span><br><span class="line">   synchronized (this) &#123;</span><br><span class="line">       mLooper = Looper.myLooper();</span><br><span class="line">       notifyAll();</span><br><span class="line">   &#125;</span><br><span class="line">   Process.setThreadPriority(mPriority);</span><br><span class="line">   onLooperPrepared();</span><br><span class="line">   Looper.loop();</span><br><span class="line">   mTid = -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public Looper getLooper() &#123;</span><br><span class="line">   if (!isAlive()) &#123;</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // If the thread has been started, wait until the looper has been created.</span><br><span class="line">   synchronized (this) &#123;</span><br><span class="line">       while (isAlive() &amp;&amp; mLooper == null) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               wait();</span><br><span class="line">           &#125; catch (InterruptedException e) &#123;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return mLooper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过wait和notifyAll保证getLooper获取的Looper对象一定是Looper.prepare之后的对象。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>《深入理解Android》</li>
<li><a href="http://blog.csdn.net/xcy2011sky/article/details/25960849" target="_blank" rel="external">http://blog.csdn.net/xcy2011sky/article/details/25960849</a></li>
<li><a href="http://www.cnblogs.com/angeldevil/p/3340644.html" target="_blank" rel="external">http://www.cnblogs.com/angeldevil/p/3340644.html</a></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Handler/">Handler</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-about-string" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/about-string/" class="article-date">
  	<time datetime="2016-04-18T08:03:53.000Z" itemprop="datePublished">2016-04-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/about-string/">关于Java String</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong><em>个人理解，如有错误，望指正。</em></strong></p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><blockquote>
<p>The String class represents character strings. All string literals in Java programs, such as “abc”, are implemented as instances of this class.</p>
<p>Strings are constant; their values cannot be changed after they are created. String buffers support mutable strings. Because String objects are immutable they can be shared.<br>String 类代表字符串。Java 程序中的所有字符串字面值（如 “abc” ）都是这个类的对象。<br>字符串是常量；它们的值在创建之后不能更改。字符串缓冲区支持可变的字符串。因为 String 对象是不可变的，所以可以共享。</p>
</blockquote>
<p><strong>String不是基本数据类型，而是一种特殊的类。String代表的是不可变的字符序列，为不可变对象，一旦被创建，就不能修改它的值，对于已经存在的String对象的修改都是重新创建一个新的对象，然后把新的值保存进去，原来的对象并没有改变。</strong></p>
<h2 id="2-特征"><a href="#2-特征" class="headerlink" title="2. 特征"></a>2. 特征</h2><p>String类具有这么几个特征：</p>
<ol>
<li>不是基本数据。</li>
<li>不可变。一旦被创建，就不能修改它的值。</li>
<li>修改方法并不会修改原对象，而是生成一个新的对象。</li>
<li>可以被共享。</li>
</ol>
<h3 id="2-1-如何理解String的不可变"><a href="#2-1-如何理解String的不可变" class="headerlink" title="2.1 如何理解String的不可变"></a>2.1 如何理解String的不可变</h3><p>首先String是一个final类，不能被继承。<br>其次，String是使用一个char数组来存放字符的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure>
<p>这个value也是final，不可变。这个变量只在String类的构造方法中初始化，之后不能改变（正常使用，非反射情况）。<br>因此，String一旦被创建就不能修改它的值。</p>
<h3 id="2-2-如何看待String提供的修改方法"><a href="#2-2-如何看待String提供的修改方法" class="headerlink" title="2.2 如何看待String提供的修改方法"></a>2.2 如何看待String提供的修改方法</h3><p>我们知道String提供一些方法例如：toUpperCase，toUpperCase等用来修改字符串。<br>其实这些方法并没有修改原来的对象，它们只是重新创建了一个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toLowerCase</span><span class="params">(Locale locale)</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> String(result, <span class="number">0</span>, len + resultOffset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假如我们执行以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   String a = <span class="string">"Hello World"</span>;</span><br><span class="line">   a = a.toUpperCase();</span><br><span class="line">   System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行之后，会生成两个对象”Hello World”和”HELLO WORLD”。而String对象的引用a的值由”Hello World”的地址变成”HELLO WORLD”的地址。而对象”Hello World”并没有改变。<br>至于这些对象在内存中的存储位置会在下面简单介绍，这里先不展开。</p>
<h3 id="2-3-String对象不可变，但是可以通过反射需改值"><a href="#2-3-String对象不可变，但是可以通过反射需改值" class="headerlink" title="2.3 String对象不可变，但是可以通过反射需改值"></a>2.3 String对象不可变，但是可以通过反射需改值</h3><p>虽然，String的value属性是一个final的属性，但是value是一个引用，它存储的其实是char数组对象的地址。那么，虽然value的引用不可变，但是这个数组对象可以改变。我们可以通过反射获取这个value指向的对象，然后修改这个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   String a = <span class="string">"Hello World"</span>;</span><br><span class="line">   System.out.println(a.hashCode());</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//获取String类中的value字段</span></span><br><span class="line">       Field  valueFieldOfString = String.class.getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">       <span class="comment">//改变value属性的访问权限</span></span><br><span class="line">       valueFieldOfString.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">       <span class="comment">//获取s对象上的value属性的值</span></span><br><span class="line">       <span class="keyword">char</span>[] value = (<span class="keyword">char</span>[]) valueFieldOfString.get(a);</span><br><span class="line">       <span class="comment">//改变value所引用的数组中的第5个字符</span></span><br><span class="line">       value[<span class="number">5</span>] = <span class="string">'_'</span>;</span><br><span class="line">       System.out.println(<span class="string">"a = "</span> + a);  <span class="comment">//Hello_World</span></span><br><span class="line">       System.out.println(a.hashCode());</span><br><span class="line">   &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：a = Hello_World</p>
<h3 id="2-4-如何实现共享"><a href="#2-4-如何实现共享" class="headerlink" title="2.4 如何实现共享"></a>2.4 如何实现共享</h3><p>首先在看看class文件的结构：</p>
<p><img src="/images/about_string/about_string_class.gif" alt="class结构"></p>
<blockquote>
<p>constant_pool 常量池<br>既然是池子，肯定是拿来放东西的，名字叫常量池，那肯定是放常量的，那哪些常量是可以放的。<br>1）放什么<br>常量池中主要存放两类内容：字面常量和符号引用。<br>字面常量主要包含文本字符串，被声明为final的常量等。<br>符号引用：因为java在编译的时候没有进行连接这一步，所有的引用都是在加载到虚拟机里动态连接的，这就要求class文件里存放这些信息。主要有以下三类常量：<br> a)类和接口的全限定名<br> b)字段的名称和描述符<br> c)方法的名称和描述符</p>
</blockquote>
<p>以上是来自<a href="http://blog.chinaunix.net/uid-21718047-id-3177289.html" target="_blank" rel="external">《最简class文件格式分析(一) class文件结构(1)》</a>关于class文件常量池的介绍。</p>
<p>就是说字面常量是存放在class文件的常量池中。</p>
<p>然后看一下JVM的结构（这是一张HotspotJVM的结构图，详细信息可以点击<a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" target="_blank" rel="external">这里</a>）</p>
<p><img src="/images/about_string/about_string_jvm.png" alt="jvm结构"></p>
<blockquote>
<p>在Java虚拟机中，关于被装载类型的信息存储在一个逻辑上被称为方法区(Method Area)的内存中，当虚拟机装载某个类型时，它使用类装载器定位相应的class文件，然后读入这个class文件——一个线性二进制数据流——然后将它传输到虚拟机中。紧接着虚拟机提取其中的类型信息，并将这些信息存储到方法区(Method Area)。该类型中的类变量(static变量)同样也是存储在方法区(Method Area)中。<br>JVM加载class后，会在方法区中为它们开辟了空间-运行常量池，用以存放类，方法，接口等中的常量，也包括字符串常量。<br>就是说String常量在类加载之后会存储在方法区的<strong>运行常量池</strong>中。<br>理解一下这个过程：java文件在编译成class文件的时候字面常量（例如String s1 = “abc”;中的abc）会存放在class文件的常量池中，JVM在加载这个class的时候将这个这些字面常量加载到方法区的运行常量池中（当然不止字面常量）。<br>（注：关于JVM结构和class文件的结构大家可以看看参考中的文章，以后再详细介绍😭）</p>
</blockquote>
<p>通过例子说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	String s1 = <span class="string">"abc"</span>;   </span><br><span class="line">	String s2 = <span class="string">"abc"</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这种声明方式的话，JVM加载类的时候会将class文件常量池的常量（abc）加载到运行常量池。当JVM执行String s1 = “abc”的语句的时候，会查找运行常量池，返回这个对象的引用。同样的s2也是返回这个引用。从而导致s1和s2同时指向abc对象的内存地址，实现了字符串共享。<br>举个例子看看是不是这样子的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   String a = <span class="string">"Hello World"</span>;</span><br><span class="line">   String b = <span class="string">"Hello World"</span>;</span><br><span class="line">   System.out.println(<span class="string">"原始 a = "</span> + a);</span><br><span class="line">   System.out.println(<span class="string">"原始 b = "</span> + b);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//获取String类中的value字段</span></span><br><span class="line">       Field valueFieldOfString = String.class.getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">       <span class="comment">//改变value属性的访问权限</span></span><br><span class="line">       valueFieldOfString.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">       <span class="comment">//获取s对象上的value属性的值</span></span><br><span class="line">       <span class="keyword">char</span>[] value = (<span class="keyword">char</span>[]) valueFieldOfString.get(a);</span><br><span class="line">       <span class="comment">//改变value所引用的数组中的第5个字符</span></span><br><span class="line">       value[<span class="number">5</span>] = <span class="string">'_'</span>;</span><br><span class="line">       System.out.println(<span class="string">"a = "</span> + a);  <span class="comment">//Hello_World</span></span><br><span class="line">       System.out.println(<span class="string">"b = "</span> + b);  <span class="comment">//Hello_World</span></span><br><span class="line">   &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原始 a = Hello World</span><br><span class="line">原始 b = Hello World</span><br><span class="line">a = Hello_World</span><br><span class="line">b = Hello_World</span><br></pre></td></tr></table></figure>
<p>说明a和b确实指向相同的String对象地址。</p>
<p><strong>因此注意：如果使用这个方式声明的String变量，那么这个String对象会存在内存中的常量池中。并且不一定会创建String对象，有可能是共享的常量池中已经存在的对象。</strong></p>
<h2 id="3-字符串拼接"><a href="#3-字符串拼接" class="headerlink" title="3. 字符串拼接"></a>3. 字符串拼接</h2><p>String允许是用+号拼接两个字符串，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"Hello"</span>;</span><br><span class="line">        String s2 = s1 + <span class="string">" World"</span>;</span><br><span class="line">        String s3 = <span class="string">"Hello"</span> + <span class="string">" World"</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(s1 + s2 + s3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个要注意，（使用jdk1.8）编译的时候变量s2会使用StringBuilder拼接，而变量s3会自动拼接成 “Hello World”。</p>
<p>我们可以通过javap -c 命令查看字节码实现。（可以参考<a href="http://www.jb51.net/article/48380.htm" target="_blank" rel="external">这里</a>）</p>
<p><img src="/images/about_string/about_string_class_code.png" alt="字节码图"></p>
<h2 id="4-方法"><a href="#4-方法" class="headerlink" title="4. 方法"></a>4. 方法</h2><h3 id="4-1-子串-substring"><a href="#4-1-子串-substring" class="headerlink" title="4.1 子串 substring"></a>4.1 子串 substring</h3><p>String类的substring方法可以从一个较大的字符串提取出一个子串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String greeting = <span class="string">"Hello"</span>;</span><br><span class="line">String s = greeting.substring(<span class="number">0</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>创建了一个有字符“Hel”组成的字符串。<br>substring方法第一个参数表示开始的位置（包括），第二个参数表示结束位置（不包括）。这样容易计算长度3-0=3。</p>
<p>然后我们看看这个方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (endIndex &gt; value.length) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(endIndex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">int</span> subLen = endIndex - beginIndex;</span><br><span class="line">   <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ((beginIndex == <span class="number">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class="keyword">this</span></span><br><span class="line">           : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先判断边界是否正确，然后通过构造器String(char value[], int offset, int count)生成String对象。<br>构造器是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">        <span class="keyword">if</span> (offset &gt; value.length - count) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset + count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是复制了一份char数组。<br>因此，这个方法也是新建了一个String对象。<strong>String方法并不会修改原对象，而是生成一个新的对象</strong></p>
<h3 id="4-2-String-intern"><a href="#4-2-String-intern" class="headerlink" title="4.2 String.intern()"></a>4.2 String.intern()</h3><p>String对象调用intern方法后，可以让JVM检查运行常量池（字符串池），如果常量池中存在与这个相等的对象就返回常量池中的对象的引用（不是该对象）；如果没有这个对象，就将本对象放入常量池并返回常量池中这个对象的引用。我的理解是：这个是时候可能有两个对象，但是最后返回的是常量池中对象的引用。为什么说是可能两个呢，举例说一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   String s1 = <span class="keyword">new</span> String(<span class="string">"Hello！！"</span>);</span><br><span class="line">   String s2 = s1.intern();</span><br><span class="line">   System.out.println(s1==s2);</span><br><span class="line"></span><br><span class="line">   String s3 = <span class="string">"World！！"</span>;</span><br><span class="line">   String s4 = s3.intern();</span><br><span class="line">   System.out.println(s3==s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>s1是堆中“Hello！！”对象的引用，s2是s1调用intern方法之后在常量池检查之后返回的引用（来自常量池）。所以这个时候是两个对象。<br>s3是常量池的中”World！！”对象引用，s4是s3调用intern方法之后在常量池检查之后返回的引用，其实是同一个对象，这个时候就一个对象。</p>
<h2 id="5-与StringBuffer-StringBuilder"><a href="#5-与StringBuffer-StringBuilder" class="headerlink" title="5. 与StringBuffer StringBuilder"></a>5. 与StringBuffer StringBuilder</h2><p>三者的区别是:</p>
<ol>
<li>String 不可变字符串。</li>
<li>StringBuffer StringBuilder 可变字符串。</li>
<li>StringBuffer 线程安全的可变字符串，它的append方法才有synchronized关键字修饰，因此是线程安全的。</li>
<li>StringBuffer StringBuilder 都继承自AbstractStringBuilder。</li>
<li>String StringBuilder StringBuffer都实现了CharSequence接口。</li>
</ol>
<p>最后，扩展一下AbstractStringBuilder这个类。AbstractStringBuilder实现Appendable, CharSequence，使用char数组保存字符串，提供很多append用来连接字符串，在append的时候都会先判断一下char数字的容量是否够，如果不够就进行扩容，然后将新字符串放入数组中。<br>我们可以看一下其中的一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">       <span class="keyword">return</span> appendNull();</span><br><span class="line">   <span class="keyword">int</span> len = str.length();</span><br><span class="line">   ensureCapacityInternal(count + len);</span><br><span class="line">   str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">   count += len;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* This method has the same contract as ensureCapacity, but is</span><br><span class="line">* never synchronized.</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// overflow-conscious code</span></span><br><span class="line">   <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>)</span><br><span class="line">       expandCapacity(minimumCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* This implements the expansion semantics of ensureCapacity with no</span><br><span class="line">* size check or synchronization.</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">expandCapacity</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> newCapacity = value.length * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">if</span> (newCapacity - minimumCapacity &lt; <span class="number">0</span>)</span><br><span class="line">       newCapacity = minimumCapacity;</span><br><span class="line">   <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (minimumCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">       newCapacity = Integer.MAX_VALUE;</span><br><span class="line">   &#125;</span><br><span class="line">   value = Arrays.copyOf(value, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次扩容的时候都是扩大2倍+2，如果比目标长度还小的话就使用目标长度。<br>这就是为什么在使用+拼接字符串的时候，编译器会将+的字符串转化为StringBuilder。因为这样子会减少创建String对象，减少开销。</p>
<h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6. 参考"></a>6. 参考</h2><p><a href="http://www.cnblogs.com/huntfor/p/3909059.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">1.JDK源码分析之String篇</a><br><a href="http://www.cnblogs.com/ITtangtang/p/3976820.html" target="_blank" rel="external">2.深入理解Java：String</a><br><a href="http://denverj.iteye.com/blog/1209506" target="_blank" rel="external">3.JVM学习笔记-方法区（Method Area</a><br><a href="http://www.cnblogs.com/iyangyuan/p/4631696.html" target="_blank" rel="external">4.触摸java常量池</a><br><a href="http://blog.chinaunix.net/uid-21718047-id-3177289.html" target="_blank" rel="external">5. 最简class文件格式分析(一) class文件结构(1)</a><br><a href="https://commons.apache.org/proper/commons-bcel/manual.html" target="_blank" rel="external">https://commons.apache.org/proper/commons-bcel/manual.html</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/String/">String</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Java/">Java</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-reflective-note" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/reflective-note/" class="article-date">
  	<time datetime="2016-04-16T07:33:45.000Z" itemprop="datePublished">2016-04-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/reflective-note/">Java反射--笔记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文是《Java 核心技术 卷I》关于反射内容的读书笔记以及理解。</p>
<h2 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1. 是什么"></a>1. 是什么</h2><blockquote>
<p>反射机制：程序运行时，允许改变程序结构或变量类型的机制。Reflection，用在Java身上指的是我们可以于运行时加载、探知、使用编译期间完全未知的classes。</p>
</blockquote>
<p>我的理解就是：反射就是在程序运行时能够动态操作Java代码的程序（或者叫机制）。</p>
<blockquote>
<p>反射是一种功能强大且复杂的机制。使用它的主要是对象是工具构造者，而不是应用程序员。</p>
</blockquote>
<h2 id="2-功能"><a href="#2-功能" class="headerlink" title="2. 功能"></a>2. 功能</h2><ol>
<li>运行中分析类</li>
<li>运行中构造任意类对象</li>
<li>运行中操作对象的方法</li>
</ol>
<h2 id="3-Class"><a href="#3-Class" class="headerlink" title="3. Class"></a>3. Class</h2><h3 id="3-1-Class类介绍"><a href="#3-1-Class类介绍" class="headerlink" title="3.1 Class类介绍"></a>3.1 Class类介绍</h3><p>书中是这样解释Class的：</p>
<blockquote>
<p>在程序运行期间，Java运行时系统始终为所有的对象维护一个被称为运行时类型标识(<em>runtime type identication</em>)。这个信息保存着每个对象所属的类足迹。虚拟机利用运行时信息选择相应的方法执行。保存这些信息的类被称为Class。</p>
</blockquote>
<p>我们再看看这个类的概述：</p>
<blockquote>
<p>Instances of the class Class represent classes and interfaces in a running Java application. An enum is a kind of class and an annotation is a kind of interface. Every array also belongs to a class that is reflected as a Class object that is shared by all arrays with the same element type and number of dimensions. The primitive Java types (boolean, byte, char, short, int, long, float, and double), and the keyword void are also represented as Class objects.<br>Class has no public constructor. Instead Class objects are constructed automatically by the Java Virtual Machine as classes are loaded and by calls to the defineClass method in the class loader.</p>
</blockquote>
<p>意思是说：</p>
<p>Class类的实例代表Java程序运行时的类（classes，枚举也是一种类）和接口（interfaces，注解也是一种接口）。还可以用来代表enum、array、primitive Java types（boolean, byte, char, short, int, long, float, double）以及关键词void。</p>
<p>Class没有public的构造方法，它是在JVM加载类的时候自动实例化的。</p>
<h3 id="3-2-获取Class对象"><a href="#3-2-获取Class对象" class="headerlink" title="3.2 获取Class对象"></a>3.2 获取Class对象</h3><ul>
<li><p>方式一：Object类的getClass()方法将会返回一个Class类实例</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Employee e;</span><br><span class="line">...</span><br><span class="line">Class cls = e.getClass();</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二：Class类的静态方法forName方法获取对应的Class类实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String className = <span class="string">"java.util.Date"</span>;</span><br><span class="line">Class cls = Class.forName(className);</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式三：如果T是Java类，那么T.class代表匹配的类对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class cls1 = Date.class;</span><br><span class="line">Class cls2 = <span class="keyword">int</span>.class;</span><br><span class="line">Class cls3 = Double[].class;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>注意：一个Class对象是用来表示一个类型（type），这个类型不一定都是类（class）。例如int不是一个类，但是int.class就是一个Class类型的对象。</strong></p>
<h3 id="3-3-简单使用"><a href="#3-3-简单使用" class="headerlink" title="3.3 简单使用"></a>3.3 简单使用</h3><p>虚拟机为每一个类型管理一个唯一Class对象（就是说一个type只对应着一个Class对象）。因此可以使用==运算符实现两个类对象的比较。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(e.getClass() == Employee.class)&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>通过Class的newInstance()方法能快速的创建一个类实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Date mDate = Date.class.newInstance();</span><br><span class="line">    <span class="comment">// 或者和forName联合使用</span></span><br><span class="line">    String s = <span class="string">"java.util.Date"</span>;</span><br><span class="line">    Object mDate2 = Class.forName(s).newInstance();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>newInstance方法调用的是类的默认构造方法（无参构造方法）初始化创建的类对象，如果该类没有默认构造方法，将会抛出异常。如果需要使用带参的构造方法的话就不能这样调用了，需要使用Constructor类中的newInstance方法。</p>
<h2 id="4-使用反射分析类"><a href="#4-使用反射分析类" class="headerlink" title="4.使用反射分析类"></a>4.使用反射分析类</h2><p>在java.lang.reflect包中有三个类Field、Method、Constructor分别用于描述普通类的域、方法和构造器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constructor[] constructors = cls.getConstructors();</span><br><span class="line">Method[] methods = cls.getMethods();</span><br><span class="line">Field[] fields = cls.getFields();</span><br></pre></td></tr></table></figure>
<p><u><strong>Class类中的getFields()、getMethods()、getConstructors()方法将返回类提供的public的域、方法和构造器，并且包括超类的共有成员。getDeclaredField()、getDeclaredMethods()、getDeclaredConstructors()能够获取全部的域、方法、构造器，包括私有的和所保护的成员，但是不包括超类的成员。</strong></u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constructor[] constructors = cls.getDeclaredConstructors();</span><br><span class="line">Method[] methods = cls.getDeclaredMethods();</span><br><span class="line">Field[] fields = cls.getDeclaredFields();</span><br></pre></td></tr></table></figure>
<p>同时：</p>
<ol>
<li>可以使用Class类以及Field、Method、Constructor都可以使用getName()获取对应的名称；</li>
<li>使用getModifiers()方法可以获取修饰符；</li>
<li>Method和Constructor使用getParameterTypes()可以获取方法和构造器的参数类型； </li>
<li>Field使用getType()方法可以获取域所属类型的Class对象，即能获取域的类型。</li>
<li>Method使用getReturnType()获取方法返回值类型。</li>
<li>对于修饰符可以使用Modifier类的静态方法toString方法获取对应的名称。Modifier还提供了例如isPublic、isPrivate或者isFinal方法来判断方法或者构造器是否是public、private或者final。</li>
</ol>
<p>打印一个类的信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printClass</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String name = cls.getName();</span><br><span class="line">        Class supCls = cls.getSuperclass();</span><br><span class="line">        printModifiers(cls.getModifiers());</span><br><span class="line">        System.out.print(<span class="string">"class "</span> + name);</span><br><span class="line">        <span class="keyword">if</span> (supCls != <span class="keyword">null</span> &amp;&amp; supCls != Object.class) &#123;</span><br><span class="line">            System.out.printf(<span class="string">" extends "</span> + supCls.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">" &#123;"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        printConstructors(cls);</span><br><span class="line">        System.out.println();</span><br><span class="line">        printMethods(cls);</span><br><span class="line">        System.out.println();</span><br><span class="line">        printFields(cls);</span><br><span class="line">        System.out.println(<span class="string">"&#125;"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printConstructors</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取构造方法</span></span><br><span class="line">        Constructor[] constructors = cls.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line">            printModifiers(constructor.getModifiers());</span><br><span class="line">            System.out.print(constructor.getName());</span><br><span class="line">            <span class="comment">// 获取方法参数</span></span><br><span class="line">            printParameters(constructor.getParameterTypes());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMethods</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line">        Method[] methods = cls.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            printModifiers(method.getModifiers());</span><br><span class="line">            Class returnCls = method.getReturnType();</span><br><span class="line">            System.out.print(returnCls.getName() + <span class="string">" "</span>);</span><br><span class="line">            System.out.print(method.getName());</span><br><span class="line">            printParameters(method.getParameterTypes());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printModifiers</span><span class="params">(<span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line">        String modifier = Modifier.toString(mod);</span><br><span class="line">        <span class="keyword">if</span> (modifier.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.print(modifier + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFields</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line">        Field[] fields = cls.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            printModifiers(field.getModifiers());</span><br><span class="line">            Class type = field.getType();</span><br><span class="line">            System.out.print(type.getName() + <span class="string">" "</span>);</span><br><span class="line">            System.out.println(field.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printParameters</span><span class="params">(Class[] parameters)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"("</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.print(<span class="string">", "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(parameters[i].getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">");"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"></span><br><span class="line">打印一下Double.class：</span><br><span class="line"></span><br><span class="line">```<span class="function">java</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        printClass(Double.class);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Double</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Number</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> java.lang.Double(<span class="keyword">double</span>);</span><br><span class="line"><span class="keyword">public</span> java.lang.Double(java.lang.String);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> java.lang.<span class="function">String <span class="title">toString</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span> java.lang.<span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">min</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">doubleToRawLongBits</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">doubleToLongBits</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">double</span> <span class="title">longBitsToDouble</span><span class="params">(<span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(java.lang.Double)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">byteValue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">shortValue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">longValue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">floatValue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">doubleValue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> java.lang.<span class="function">Double <span class="title">valueOf</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> java.lang.<span class="function">Double <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> java.lang.<span class="function">String <span class="title">toHexString</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNaN</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNaN</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isInfinite</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInfinite</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFinite</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">parseDouble</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> POSITIVE_INFINITY</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> NEGATIVE_INFINITY</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> NaN</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> MAX_VALUE</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> MIN_NORMAL</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> MIN_VALUE</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_EXPONENT</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_EXPONENT</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BYTES</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.Class TYPE</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> value</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-使用反射分析对象"><a href="#5-使用反射分析对象" class="headerlink" title="5.使用反射分析对象"></a>5.使用反射分析对象</h2><p>前面我们获取了对象（或者说类）的域名称和类型。那么如何获取域的值呢？</p>
<p>使用Field的get(obj)方法获取:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">User mUser = <span class="keyword">new</span> User(<span class="string">"Jim"</span>, <span class="number">15</span>);<span class="comment">// name和age</span></span><br><span class="line">Class cls = mUser.getClass();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     Field nameField = cls.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">     Object name = nameField.get(mUser);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，如果name是private的话是会抛出java.lang.IllegalAccessException异常的。因为，反射机制的默认行为受限于Java的访问限制。这个时候需要使用setAccessible(true)覆盖访问控制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">User mUser = <span class="keyword">new</span> User(<span class="string">"Jim"</span>, <span class="number">15</span>);</span><br><span class="line">Class cls = mUser.getClass();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Field nameField = cls.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">  nameField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">  Object name = nameField.get(mUser);</span><br><span class="line">  System.out.println(name);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，如果是获取基本类型的话可以使用Field的对应方法，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Field ageField = cls.getDeclaredField(<span class="string">"age"</span>);</span><br><span class="line">ageField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">int</span> age = ageField.getInt(mUser);</span><br></pre></td></tr></table></figure>
<p>setAccessible是AccessibleObject类的方法，AccessibleObject是Field、Method、Constructor       的超类。</p>
<h2 id="6-使用反射操作数组"><a href="#6-使用反射操作数组" class="headerlink" title="6.使用反射操作数组"></a>6.使用反射操作数组</h2><p>java.lang.reflect包下的Array类使用操作数组的，可以使用Array的静态方法newInstance构建新的数组，使用getLength获取数组长度，使用get、getXXX获取数组数组自定位置的内容，使用set、setXXX设置内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ary[] = (<span class="keyword">int</span>[]) Array.newInstance(<span class="keyword">int</span>.class, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Array.getLength(ary); i++) &#123;</span><br><span class="line">  Array.set(ary, i, i * i);</span><br><span class="line">  <span class="comment">// Array.setInt(ary, i, i * i);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-使用反射操作方法"><a href="#7-使用反射操作方法" class="headerlink" title="7.使用反射操作方法"></a>7.使用反射操作方法</h2><blockquote>
<p>Recall that you can inspect a field of an object with the get method of the Field class. Similarly, the Method class has an invoke method that lets you call the method that is wrapped in the current Method object. The signature for the invoke method is<br>Object invoke(Object obj, Object… args)<br>The first parameter is the implicit parameter, and the remaining objects provide the explicit parameters.<br>For a static method, the first parameter is ignored—you can set it to null.</p>
</blockquote>
<p>Method类提供了一个invoke方法用来包装当前对象的方法：<br>Object invoke(Object obj, Object… args)<br>第一个参数是隐藏参数，表示调用方法的对象；其他参数为显示参数，用以表示方法的参数。如果是静态方法，第一个参数为null。</p>
<p>假如User类有一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以通过反射这样调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  User demo = <span class="keyword">new</span> User();</span><br><span class="line">  Method m = demo.getClass().getDeclaredMethod(<span class="string">"calculate"</span>, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">  <span class="keyword">int</span> value = (<span class="keyword">int</span>) m.invoke(demo, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  System.out.println(<span class="string">"反射计算:"</span> + value);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于静态方法，我们假如调用Math的sqrt(double)方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Method sqrtMethod = Math.class.getDeclaredMethod(<span class="string">"sqrt"</span>, <span class="keyword">double</span>.class);</span><br><span class="line">  <span class="keyword">double</span> value = (<span class="keyword">double</span>) sqrtMethod.invoke(<span class="keyword">null</span>, <span class="number">4</span>);</span><br><span class="line">  System.out.printf(<span class="string">"%.1f"</span>,value);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ol>
<li>使用invoke方法获取的值是Object的。</li>
<li>使用invoke反射会比直接调用方法明显慢一些。</li>
</ol>
<p><strong>所以：仅在必要的时候才使用Method对象。</strong></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/反射/">反射</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Java/">Java</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-fragment-arg" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/fragment-arg/" class="article-date">
  	<time datetime="2016-04-15T03:53:36.000Z" itemprop="datePublished">2016-04-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/fragment-arg/">使用注解操作Fragment Argument</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近做了一个操作Fragment的Argument的简便方式，使用注解在编译时生成操作Argument的代码，在Fragment注入获取代码，完成对Argument的操作。</p>
<p>这样的轮子已经有了<a href="https://github.com/sockeqwe/fragmentargs" target="_blank" rel="external">这个</a>，再造的同时，顺便学习一下编译时注解，另外可以自定义自己的需求。</p>
<p>项目地址在这里<a href="https://github.com/qinglinyi/FragmentArg" target="_blank" rel="external">https://github.com/qinglinyi/FragmentArg</a></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">'com.android.tools.build:gradle:2.0.0'</span></span><br><span class="line">        classpath <span class="string">'com.neenbedankt.gradle.plugins:android-apt:1.4'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'com.neenbedankt.android-apt'</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="function">compile <span class="title">fileTree</span><span class="params">(dir: <span class="string">'libs'</span>, include: [<span class="string">'*.jar'</span>])</span></span><br><span class="line">    compile 'com.qinglinyi.arg:arg-api:0.9.0'</span><br><span class="line">    apt 'com.qinglinyi.arg:arg-compiler:0.9.0'</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apt </span>&#123;</span><br><span class="line">    arguments &#123;</span><br><span class="line">        <span class="comment">// FragmentBuilder的包</span></span><br><span class="line">        argPackageName <span class="string">"com.qinglinyi.arg.sample"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Fragment</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UseArg</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Arg</span></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Arg</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Arg</span></span><br><span class="line">    ArrayList&lt;String&gt; interests;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Arg</span></span><br><span class="line">    String[] friendNames;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        ArgInjector.inject(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p><strong>Activity</strong>两种方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mFragment0 = FragmentBuilder.builder(<span class="keyword">new</span> MyFragment())</span><br><span class="line">               .age(<span class="number">15</span>)</span><br><span class="line">               .name(<span class="string">"张三"</span>)</span><br><span class="line">               .friendNames(<span class="keyword">new</span> String[]&#123;<span class="string">"李四"</span>, <span class="string">"王五"</span>&#125;)</span><br><span class="line">               .interests(list)</span><br><span class="line">               .build();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mFragment1 = <span class="keyword">new</span> MyFragmentBuilder().age(<span class="number">15</span>)</span><br><span class="line">               .name(<span class="string">"李四"</span>)</span><br><span class="line">               .friendNames(<span class="keyword">new</span> String[]&#123;<span class="string">"张三"</span>, <span class="string">"王五"</span>&#125;)</span><br><span class="line">               .interests(list)</span><br><span class="line">               .build();</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Fragment/">Fragment</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-publish-to-jcenter" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/publish-to-jcenter/" class="article-date">
  	<time datetime="2016-04-06T06:59:13.000Z" itemprop="datePublished">2016-04-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/posts/publish-to-jcenter/">Android Studio 发布项目到jcenter库</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>转载请注明：<a href="http://www.qinglinyi.com/posts/publish-to-jcenter/">http://www.qinglinyi.com/posts/publish-to-jcenter/</a></p>
<p>第一次发布项目到jcenter，虽然网上有很多教程了，但是过程还是比较曲折。不过最终还是找到简单的方式，使用com.novoda.bintray-release实现发布。</p>
<h2 id="认识jcenter"><a href="#认识jcenter" class="headerlink" title="认识jcenter"></a>认识jcenter</h2><p>我们经常在android studio项目中看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>那么jcenter到底是什么呢？</strong></p>
<p>我们可以将jcenter理解为<strong>代码仓库</strong>。如果我们在builde.gradle文件中设置例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.google.code.gson:gson:2.3.1&apos;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/记录/">记录</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/posts/publish-to-jcenter/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2018 青林亦
    		<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1257786708'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1257786708%26online%3D1%26show%3Dline' type='text/javascript'%3E%3C/script%3E"));</script>
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>